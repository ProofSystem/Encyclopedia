% If the calculus has an acronym, define it.
	% (e.g. \newcommand{\LK}{\ensuremath{\mathbf{LK}}\xspace})
	
	\calculusName{Second Order $\lambda$-Calculus (System $\SystemF$)} 
	\calculusAcronym{\SystemF} 
	\calculusLogic{Type Theory} 
	\calculusLogicOrder{Quantified Propositional}

	\calculusType{Natural Deduction} 
	%\calculusType{Sequential Natural Deduction with Labels} 
	\calculusYear{1971} 
	\calculusAuthor{Jean-Yves Girard} 
	
	
	\entryTitle{Second Order $\lambda$-Calculus (System F)} 
	\entryAuthor{Giuseppe Longo} \entryAuthor{Kathleen Milsted} \entryAuthor{Sergei Soloviev}  
	
	
	% If you wish, use tags to give any other information
	% that might be helpful for classifying and grouping this entry:
	% e.g. \etag{Two-Sided Sequents}
	% e.g. \etag{Multiset Cedents}
	% e.g. \etag{List Cedents}
	% You are free to invent your own tags.
	% The Encyclopedia's coordinator will take care of
	% merging semantically similar tags in the future.

	
	\maketitle
	
	
	% If your files are called "<ID>.tex" and "<ID>.bib",
	% then you should write "\begin{entry}{<ID>}" in the line below
	\begin{entry}{fc}
        %\begin{entry}{fc}
	
	% Define here any newcommands you may need:
	% e.g. \newcommand{\necessarily}{\Box}
	% e.g. \newcommand{\possibly}{\Diamond}
	
	
	\begin{calculus}
	
\vspace{-5pt}

	% Add the inference rules of your proof system here

\centering
$$
\infer[\mathrm{assumption}]{\Gamma; E \seq x: T}{(x:T)\in E}
$$
  \[
  \begin{array}{l@{\qquad}l}
\infer[\rightarrow{I}]
{\Gamma; E \seq (\lambda x:T.e):(T\rightarrow S)}
{\Gamma; E, (x:T) \seq e: S}
  &
  \infer[\rightarrow{E}]{\Gamma; E \seq (fe): S}
{\Gamma; E \seq f: (T\rightarrow S) &
    \Gamma; E \seq e: T}
  \medskip\\
\infer[\forall{I^*}]
{\Gamma; E \seq (\Lambda X:Tp.e):(\forall X:Tp.T)}
{\Gamma\, X; E \seq e: T}
  &
  \infer[\forall{E}]{\Gamma; E \seq fS:[S/X]T}
{\Gamma; E \seq f:(\forall X:Tp.T) & \Gamma\seq S:Tp}
  \medskip\\
  \end{array}
  \]

\small{* $X$ must be not free in the type of any free term variable in $E$.}

%\centering
%$$ \infer[\mathrm{Ax\, C}]{\Gamma \seq M\tau = M\tau': \sigma}{\Gamma \seq M:\forall X\sigma & X\notin FV(\sigma)}
%$$
	% The "proof.sty" and "bussproofs.sty" packages are available.
	% If you need any other package, please contact the editor (bruno@logic.at)
	
	\end{calculus}
	
	% The following environments ("clarifications", "history",
	% "technicalities") are optional. If you do use them,
	% be very concise and objective.
	
	\begin{clarifications}
	 The presentation from~\cite{AspLongo:91} with minor corrections is used. $X, Y, Z...$ are type-variables and $x, y, ...$ term variables. Expressions are type ($T:= X | (T\rightarrow S)|(\forall X:Tp.T)$) or terms ($e:= x|(ee)|(eT)|(\lambda x:T.e)|(\Lambda X:Tp.e)$).  
%
$\forall, \Lambda$ and $\lambda$ are variable binders. All expressions are considered up to renaming of bound variables
($\alpha$-conversion). An unbound variable is free. $FV(R)$ is the set of free
variables for any (type or term) expression; $[e/x]$, $[S/X]$ mean capture-avoiding substitution in term- and type-expressions respectively (defined by induction). 
A context is a finite set $\Gamma$ of type variables; $\Gamma X$ stands for $\Gamma\cup{X}$. A type $T$ is legal in $\Gamma$ iff 
$FV(T)\subseteq FV(\Gamma)$. A type assignment in $\Gamma$ is a finite list
$E = (x_1:T_1),..., (x_n:T_n)$ where any $T_i$ is legal in $\Gamma$. 
The typing
relation $\Gamma; E\seq e:T$, where $E$ is a type assignment legal in $\Gamma$,
$e$ is a term and $T$ is a type, is defined by the rules
above.
%
The {\em conversion relation} between well-typed 
terms is very important. It is defined
by the following axioms: ($\beta$) $(\lambda x:T.f)e = [e/x]f$; 
($\beta_2$) $(\Lambda X:Tp.e)S=[S/X]e$; $(\eta)$ $\lambda x:T.(ex)=e$ if 
$x\notin FV(e)$; $(\eta_2)$ $\Lambda X:Tp.(eX) = e$ if 
$X\notin FV(e)$, and by usual rules that turn ``$=$'' into congruence.
The system $\SystemF_c$ is obtained if one more equality axiom is added:
({\bf C})\,\,\,\, $eT = eT'$ for $\Gamma; E\seq e:\forall X.S$ and $X\notin FV(S)$.
	% ToDo: write here short remarks that may help the reader to understand
	% the inference rules of the proof system.
	\end{clarifications}
	
	\begin{history}
It was introduced in~\cite{Gir:71,Rey:74} and included in the $\lambda$-cube~\cite{Bar:91}. It is important for functional programming and inspired works on higher order type systems and many extensions (e.g. $\SystemF_c$~\cite{LMS:93}, $\SystemF$ with subtyping~\cite{CMMS:91, LMS:00}).
	\end{history}
	
	\begin{technicalities}
A strong normalization theorem for $\SystemF$ was proved by Girard
~\cite{Gir:72}. It implies a normalization theorem and consistency for second
order arithmetic $PA_2$. For $\SystemF_c$, a {\em genericity theorem} holds~\cite{LMS:93}.
	% ToDo: write here remarks about soundness, completeness, decidability...
	\end{technicalities}
	
\vspace{-10pt}
	
	
	
	
	\end{entry}
