
% If the calculus has an acronym, define it.
% (e.g. \newcommand{\LK}{\ensuremath{\mathbf{LK}}\xspace})
\calculusName{Ordered Fine-Grained Resolution with Selection} % The name of the calculus
\calculusAcronym{}          % The acronym if defined above, or empty otherwise. 
\calculusLogic{Monodic First Order Temporal Logic}        % Specify the logic (e.g. Classical Logic, Intuitionistic Logic, ...) for which this calculus is intended.
\calculusLogicOrder{First-Order}   % Specify the order of the logic (e.g. Propositional, Quantified Propositional, First-Order, Higher-Order, ...).
\calculusType{Resolution}         % Specify the calculus type (e.g. Tableau, Sequent Calculus, Hyper-Sequent Calculus, Natural Deduction, ...)
\calculusYear{2009}         % The year when the calculus was published.

\calculusAuthor{Michael Ludwig}
\calculusAuthor{Ullrich Hustadt}      % The name(s) of the author(s) of the calculus.
\entryTitle{Ordered Fine-Grained Resolution with Selection for Monodic First-Order Temporal Logic}     % Title of the entry (usually coincides with the name of the calculus).
\entryAuthor{Ullrich Hustadt}
\implementation{TSPASS}{http://cgi.csc.liv.ac.uk/~michael/TLBook/TSPASS-System/}

% The encyclopedia's peer-reviewing policy is described here: 
% http://proofsystem.github.io/Encyclopedia/
%
% Reviewers of this entry will be acknowledged in the following lines:
% \entryReviewer{Reviewer 1's name}
% \entryReviewer{Reviewer 2's name}
% \entryReviewer{Reviewer 3's name}
%
% The lines above will be filled by the coordinators. 
% If you would like to indicate people 
% who could review your entry, contact the coordinators.


% If you wish, use tags to give any other information 
% that might be helpful for classifying and grouping this entry:
% \tag{Monodic First-Order Temporal Logic}
% e.g. \tag{Multiset Cedents}
% e.g. \tag{List Cedents}
% You are free to invent your own tags. 
% The Encyclopedia's coordinator will take care of 
% merging semantically similar tags in the future.


\maketitle


% If your files are called "MyProofSystem.tex" and "MyProofSystem.bib", 
% then you should write "\begin{entry}{MyProofSystem}" in the line below
\begin{entry}{FOTLFineGrainedResolution}  

% Define here any newcommands you may need:
% e.g. \newcommand{\necessarily}{\Box}
% e.g. \newcommand{\possibly}{\Diamond}

\newcommand{\ProverState}[3]{\ensuremath{#1\,|\,#2\,|\, #3}}
\newcommand{\NewSet}{\ensuremath{\mathcal{N}}}
\newcommand{\ProcessedSet}{\ensuremath{\mathcal{P}}}
\newcommand{\OldSet}{\ensuremath{\mathcal{O}}}
\newcommand{\Set}[2]{\{\,#1 \mid #2\,\}}
\newcommand{\SetEnum}[1]{\{#1\}}
\newcommand{\predset}[2]{\{#1\;|\;#2\}}
\newcommand{\existentialClosure}{\tilde{\exists}}
\newcommand{\existentialClosureExc}[1]{\existentialClosure_{\backslash #1}}
\newcommand{\EmptyClause}{\ensuremath{\bot}}
%\newcommand{\Next}[0]{\mathop{\raisebox{0.2ex}{\scalebox{0.9}{\ensuremath{\ocircle}}}}}
\newcommand{\Always}[0]{\mathop{\scalebox{1.25}{\ensuremath{\Box}}}}
\newcommand{\Sometimes}[0]{\Diamond}
\newcommand{\Eventually}[0]{\Diamond}

\newcommand{\Next}{\!\raisebox{0.1ex}{ %possibly add a little space before
                        \mbox{\unitlength=0.62ex
                        \begin{picture}(2,2)
                        \linethickness{0.1ex}
                        \put(1,1){\circle{2}} % Draws circle with
                        \end{picture}}}       % diameter 2 at centre 1,1
                        \,}

\newcommand{\TAlways}{\raisebox{-.2ex}{
                           \mbox{\unitlength=0.9ex
                           \begin{picture}(2,2)
                           \linethickness{0.06ex}
                           \put(0,0){\line(1,0){2}}
                           \put(0,2){\line(1,0){2}}
                           \put(0,0){\line(0,1){2}}
                           \put(2,0){\line(0,1){2}}
                           \end{picture}}}
                       \,}
\newcommand{\TSometime}[0]{\hbox{$\,\Diamond \,$}}


% \newcommand{\ltrue}{{\bf true}}
% \newcommand{\lfalse}{{\bf false}}


%\newcommannd{\mC}[1]{\mathcal{#1}}

\begin{calculus}
% Add the inference rules of your proof system here.
% The "proof.sty" and "bussproofs.sty" packages are available.
% If you need any other package, please contact the coordinator (Bruno
% Woltzenlogel Paleo <bruno.wp@gmail.com>) 
%
The calculus consists of the six \emph{inference rules} below that
operate on individual clauses as well as \emph{derivation rules} that
operate on sets of clauses:
%\newcommand{\myspace}{2ex}
%\vspace{-\myspace}
\vspace*{-1ex}
\[
\begin{array}{c@{\hspace*{1.8em}}c@{\hspace*{1.8em}}c}
\infer[]%[R]
{ (D_1\lor D_2)\sigma }
{ D_1\lor L_1 & \neg L_2\lor D_2}
&
 \infer[]%[F]
 {(D_3\lor L_1)\sigma}
 {D_3\lor L_1\lor L_2}
&
\infer[]%[C]
 {\neg C_1}
 {C_1\rightarrow\Next\bot}
\\
\\[-1ex]
%\end{array}\vspace*{-1ex}
%\]
%where $\sigma$ is a most general unifier of the literals $L_1$ and $L_2$, 
%$L_1$ is eligible in $D_1\lor L_1$ for $\sigma$,
%$\neg L_2$ is eligible in $\neg L_2\lor D_2$ for $\sigma$,
%$L_1$ is eligible in $D_3\lor L_1\lor L_2$ for $\sigma$.
%\[
%\begin{array}{c@{\hspace{1.8em}}c@{\hspace{1.8em}}c}
 \infer[]%[\mathit{SS}]
{(C_1\land C_2)\sigma\rightarrow\Next(D_1\lor D_2)\sigma}
{C_1\rightarrow\Next(D_1\lor L_1) & 
 C_2\rightarrow\Next(\neg L_2\lor D_2)}
&
 \infer[]%[\mathit{SU}]
{C_1\sigma\rightarrow\Next(D_1\lor D_2)\sigma}
{C_1\rightarrow\Next(D_1\lor L_1) & \neg L_2\lor D_2}
&
 \infer[]%\mathit{SF}]
 {C_3\sigma\rightarrow\Next(D_3\lor L_1)\sigma}
 {C_3\rightarrow\Next(D_3\lor L_1\lor L_2)}
\end{array}\vspace*{-1.5ex}
 \]
where 
%$C_1\rightarrow\Next(D_1\lor A)$ and
%$C_2\rightarrow\Next(D_2\lor\neg B)$ are step clauses, 
$\sigma$ is a most general unifier of the literals $L_1$ and $L_2$ 
such that $\sigma$ does not map variables from $C_1$ or $C_2$ into 
a constant or a functional term, 
$L_1$ is eligible in $D_1\lor L_1$ for $\sigma$,
$\neg L_2$ is eligible in $D_2\lor\neg L_2$ for $\sigma$, and
$L_1$ is eligible in $D_3\lor L_1\lor L_2$ for $\sigma$.

By $\mathrm{Res}(C,\mathcal{O})$ we denote the set of all clauses
derivable from clause $C$ with clauses in $\mathcal{O}$ using the
inference rules above.

Derivations are constructed according to the \emph{derivation rules}
below:\vspace*{-2ex}
\begin{align*}
% Initialisation
\langle \mathcal{U}, \mathcal{I}, \mathcal{S}, \mathcal{E} \rangle
&\Longrightarrow
\ProverState{\mathcal{N}}{\emptyset}{\emptyset}
\parbox[t]{25em}{\ 
\begin{tabular}[t]{@{}l@{}}
where
$\mathcal{N} = \mathcal{U}
\begin{array}[t]{@{}l@{}}
\hbox{}\cup \mathcal{I} \cup \mathcal{S}\\
\hbox{}\cup \Set{P(c^L) \supset \Next Q(c^L)}{P(x) \implies \Next Q(x) \in
  \mathcal{S}, \Eventually L(x)\in\mathcal{E}}\\
\hbox{}\cup \Set{s^{L,1}_0 \supset \Next L(c^L}{\Eventually L(x) \in
  \mathcal{E}}
\cup \Set{s^{L,0}_0 \supset \Next L}{\Eventually L \in
  \mathcal{E}}
\end{array}
$
\end{tabular}}
\\
% Loop Search Contradiction
\ProverState{\emptyset}{\ProcessedSet \cup 
\SetEnum{s^{L,k}_i \implies \Next\EmptyClause}}{\OldSet}
&\Longrightarrow
\makebox[187pt][l]{$\ProverState{\SetEnum{\EmptyClause}}{\ProcessedSet}{\OldSet \cup 
\SetEnum{s^{L,k}_i \implies \Next \EmptyClause}}$}
\mbox{ for some $i, k, L$}
\\
% Next Loop Search Iteration (Non-ground)
\ProverState{\emptyset}{\ProcessedSet \cup 
\SetEnum{s^{L,1}_i \land C \implies \Next\EmptyClause}}{\OldSet}
&\Longrightarrow
\makebox[187pt][l]{\ProverState{\SetEnum{s^{L,1}_{i+1} \implies \Next \lnot C \lor
L(c^l)}}{\ProcessedSet}{\OldSet \cup 
\SetEnum{s^{L,1}_i \land C \implies\Next\EmptyClause}}}
\mbox{ for some $i,L$ and $C \neq \emptyset$}\makebox[12pt][l]{}
\\
% Next Loop Search Iteration (Ground)
\ProverState{\emptyset}{\ProcessedSet \cup 
\SetEnum{s^{L,0}_i \land C \implies \Next\EmptyClause}}{\OldSet}
&\Longrightarrow
\makebox[187pt][l]{$\ProverState{\SetEnum{s^{L,0}_{i+1} \implies \Next \lnot C \lor
L}}{\ProcessedSet}{\OldSet \cup 
\SetEnum{s^{L,0}_i \land C \implies\Next\EmptyClause}}$}
\mbox{ for some $i,L$ and $C \neq \emptyset$}
\\
% Regular Inference Computation
\ProverState{\emptyset}{\ProcessedSet \cup \SetEnum{\mathcal{C}}}{\OldSet}
&\Longrightarrow
\makebox[56pt][l]{$\ProverState{\NewSet}{\ProcessedSet}{\OldSet \cup \SetEnum{\mathcal{C}}}$}
\mbox{ if none of the previous rule applies and $\NewSet = \mathrm{Res}(\mathcal{C}, \OldSet)$}
\\
% Loop Testing (Non-ground)
\ProverState{\emptyset}{\ProcessedSet}{\OldSet}
&\Longrightarrow
\begin{array}[t]{@{}l@{}}
\ProverState{%
\Set{\Always \forall x \neg H_{i+1}^L(x)}{\mbox{for all $i$,
$L$ with } \models \forall x (H_i^L(x) \Leftrightarrow H_{i+1}^L(x))}%
}{\ProcessedSet}{\OldSet}\\
\mbox{where }
H_i^L(x) := \bigvee \predset{(\existentialClosure C_j)\{c^l /
x\}}{s_i^{L,1}\land C_j\imp\Next\bot\in \ProcessedSet \cup \OldSet}
\mbox{ for all $i$, $L$}
\end{array}
\\
% Loop Testing (Ground)
\ProverState{\emptyset}{\ProcessedSet}{\OldSet}
&\Longrightarrow
\begin{array}[t]{@{}l@{}}
\ProverState{%
\Set{\Always \neg H_{i+1}^L}{\mbox{for all $i$,
$L$ with } \models (H_i^L \Leftrightarrow H_{i+1}^L)}%
}{\ProcessedSet}{\OldSet}\\
\mbox{where }
H_i^L := \bigvee 
\predset{C_j}{s_i^{L,0}\land C_j\imp\Next\bot\in \ProcessedSet \cup \OldSet}
\mbox{ for all $i$, $L$}
\end{array}
\\
% \ProverState{\NewSet \cup \SetEnum{\mathcal{C}}}{\ProcessedSet}{\OldSet}
% &\Longrightarrow
% \ProverState{\NewSet}{\ProcessedSet \cup \SetEnum{\mathcal{C}}}{\OldSet}$
% \mbox{ if none of the previous rules applies}
%
% % Tautology Deletion
% \ProverState{\NewSet \cup \SetEnum{\mathcal{C}}}{\ProcessedSet}{\OldSet}
% &\Longrightarrow
% \makebox[100pt][l]{$\ProverState{\NewSet}{\ProcessedSet}{\OldSet}$}
% \mbox{ if $\mathcal{C}$ is a tautology}
% \\
% % Forward Subsumption
% \ProverState{\NewSet \cup \SetEnum{\mathcal{C}}}{\ProcessedSet}{\OldSet}
% &\Longrightarrow
% \makebox[100pt][l]{$\ProverState{\NewSet}{\ProcessedSet}{\OldSet}$}
% \mbox{ if some clause in $\ProcessedSet \cup \OldSet$ subsumes $\mathcal{C}$}
% \\
% % Backward Subsumption
% \ProverState{\NewSet}{\ProcessedSet  \cup \SetEnum{\mathcal{C}}}{\OldSet}
% &\Longrightarrow
% \makebox[100pt][l]{$\ProverState{\NewSet}{\ProcessedSet}{\OldSet}$}
% \mbox{ if some clause in $\NewSet$ properly subsumes $\mathcal{C}$}
% \\
% % Backward Subsumption
% \ProverState{\NewSet}{\ProcessedSet}{\OldSet \cup \SetEnum{\mathcal{C}}}
% &\Longrightarrow
% \makebox[100pt][l]{$\ProverState{\NewSet}{\ProcessedSet}{\OldSet}$}
% \mbox{ if some clause in $\NewSet$ properly subsumes $\mathcal{C}$}
% \\
% Clause Processing
\ProverState{\NewSet \cup \SetEnum{\mathcal{C}}}{\ProcessedSet}{\OldSet}
&\Longrightarrow
\makebox[56pt][l]{$\ProverState{\NewSet}{\ProcessedSet\cup\SetEnum{\mathcal{C}}}{\OldSet}$}
\mbox{ if none of the previous rules applies}
\end{align*}
\end{calculus}

% The following sections ("clarifications", "history", 
% "technicalities") are optional. If you use them, 
% be very concise and objective. Nevertheless, do write full sentences. 
% Try to have at most one paragraph per section, because line breaks 
% do not look nice in a short entry.

 \begin{clarifications}
% ToDo: write here short remarks that may help the reader to understand 
% the inference rules of the proof system.
%
To determine the satisfiability of a formula $\varphi$ of monodic first-order
discrete linear time temporal logic over expanding domains, the
formula $\varphi$ is transformed into a \emph{Clausal Monodic Temporal Problem}
$\mathcal{P} = \langle \mathcal{U, I, S, E} \rangle$ 
where $\mathcal{U}$
% (the universal part) 
and $\mathcal{I}$ 
% (the step part) 
are sets of first-order clauses;
$\mathcal{S}$ 
% (the step part) 
is a set of \emph{step clauses} of the form
$p\rightarrow\Next q$,
where $p$ and $q$ are propositions, or
$P(t)\rightarrow\Next Q(t)$, where $P$ and $Q$ are unary predicates
and $t$ is either a variable or a constant;
$\mathcal{E}$  
% (the eventuality part) 
is a set of \emph{eventuality clauses}
of the form $\Eventually L$, where $L$ is a propositional literal,
$\Eventually (\neg)P(t)$, where $P$ is a unary predicate and $t$ is
either a constant or a variable.
%
Inferences are restricted by an \emph{ordering} $\succ$ on literals
and a subsumption-compatible \emph{selection function} $S$. $S$ maps
any first-order clause $C$ to a possibly empty subset of its negative literals. 
A literal $L$ is \emph{eligible} in a clause $L\lor C$ for a
substitution $\sigma$ if either $L\in S(C)$, or $S(C)=\emptyset$  and
$L\sigma$ is $\succ$-maximal wrt $C\sigma$.
\end{clarifications}

\begin{history}
% ToDo: write here short historical remarks about this proof system,
% especially if they relate to other proof systems. 
% Use "\iref{OtherProofSystem}" to refer to another proof system 
% in the Encyclopedia (where "OtherProofSystem" is its ID). 
% Use "\irefmissing{SuggestedIDForOtherProofSystem}" to refer to 
% another proof system that is not yet available in the encyclopedia.
Related to~\iref{FOTLResolution}, this calculus was introduced in
\cite{Ludwig+Hustadt@CADE2009}.
It has been implemented in the prover TSPASS~\cite{Ludwig+Hustadt@AIC2010}.
Satisfiability equivalence of the transformation, soundness and
refutational completeness of the calculus are shown in~\cite{Ludwig@Liverpool2010}.
%A later
%implementation focusing on fair derivations is provided in
%TSPASS~\cite{Ludwig+Hustadt@CADE2009,Ludwig+Hustadt@AIC2010}.
\end{history}

%\begin{technicalities}
%% ToDo: write here remarks about soundness, completeness,
%% decidability...
%Soundness, completeness and termination are shown in~\cite{DBLP:journals/tocl/DegtyarevFK06}.
%\end{technicalities}


% General Instructions:
% =====================

% The preferred length of an entry is 1 page. 
% Do the best you can to fit your proof system in one page.
%
% If you are finding it hard to fit what you want in one page, remember:
%
%   * Your entry needs to be neither self-contained nor fully understandable
%     (the interested reader may consult the cited full paper for details)
%
%   * If you are describing several proof systems in one entry, 
%     consider splitting your entry.
%
%   * You may reduce the size of your entry by ommitting inference rules
%     that are already described in other entries.
%
%   * Cite parsimoniously (see detailed citation instructions below).
%
% 
% If you do not manage to fit everything in one page, 
% it is acceptable for an entry to have 2 pages.
%
% For aesthetic reasons, it is preferable for an entry to have
% 1 full page or 2 full pages, in order to avoid unused blank space.



% Citation Instructions:
% ======================

% Please cite the original paper where the proof system was defined.
% To do so, you may use the \cite command within 
% one of the optional environments above,
% or use the \nocite command otherwise.

% You may also cite a modern paper or book where the 
% proof system is explained in greater depth or clarity.
% Cite parsimoniously.

% Do not cite related work. Instead, use the "\iref" or "\irefmissing" 
% commands to make an internal reference to another entry, 
% as explained within the "history" environment above.

% You do not need to create the "References" section yourself. 
% This is done automatically.


% Remove all instruction comments before submitting.


% Leave an empty line above "\end{entry}".

\end{entry}
