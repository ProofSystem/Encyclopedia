\calculusName{Resolution for Computational Tree Logic}
\calculusAcronym{}
\calculusLogic{Temporal Logics}
\calculusLogicOrder{Propositional}
\calculusType{Resolution}
\calculusYear{2009}

\calculusAuthor{Lan Zhang}
\calculusAuthor{Ullrich Hustadt}
\calculusAuthor{Clare Dixon}

\entryTitle{Resolution for Computation Tree Logic (CTL)}
\entryAuthor{Clare Dixon}     
\entryAuthor{Ullrich Hustadt}


\maketitle

\begin{entry}{CTLClausalResolution}  

%\newcommand{\Next}[0]{\mathop{\raisebox{0.2ex}{\scalebox{0.9}{\ensuremath{\ocircle}}}}}
\newcommand{\Always}[0]{\mathop{\scalebox{1.25}{\ensuremath{\Box}}}}
\newcommand{\Sometimes}[0]{\mathop{\Diamond}}
\newcommand{\Eventually}[0]{\Diamond}

\newcommand{\Next}{\!\raisebox{0.1ex}{ %possibly add a little space before
                        \mbox{\unitlength=0.62ex
                        \begin{picture}(2,2)
                        \linethickness{0.1ex}
                        \put(1,1){\circle{2}} % Draws circle with
                        \end{picture}}}       % diameter 2 at centre 1,1
                        \,}

\newcommand{\TAlways}{\raisebox{-.2ex}{
                           \mbox{\unitlength=0.9ex
                           \begin{picture}(2,2)
                           \linethickness{0.06ex}
                           \put(0,0){\line(1,0){2}}
                           \put(0,2){\line(1,0){2}}
                           \put(0,0){\line(0,1){2}}
                           \put(2,0){\line(0,1){2}}
                           \end{picture}}}
                      \,}
\newcommand{\TSometime}{\hbox{$\,\Diamond \,$}}

\newcommand{\lstart}{{\mathbf{start}}}
\newcommand{\ltrue}{{\mathbf{true}}}
\newcommand{\lfalse}{{\mathbf{false}}}

\def\unless{\hbox{$\,\mathcal W \,$}}

\def\allpaths{\ensuremath{\mathbf A}}

\def\somepath{\ensuremath{\mathbf{E}}}

\def\somepathind{\ensuremath{\mathbf{E}_{\langle ind \rangle}}}

\def\eitherpath{\ensuremath{\mathbf{P}}}


\begin{calculus}

\newcommand{\myspace}{-5pt}

\begin{small}
%\vspace{\myspace}
\[
\infer %[\textit{Initial Resolution}]
{\allpaths \Always (\lstart \rightarrow (C \lor D))}
{\allpaths\Always( \lstart \rightarrow (C \lor l))  &
\allpaths\Always(\lstart \rightarrow (D \lor \neg l))} 
%
\qquad
%
\infer %[\textit{Step Resolution}]
{\allpaths\Always(P \land Q  \rightarrow  \somepathind 
  \Next (C \lor D))}
{\allpaths\Always(P \rightarrow \somepathind\Next (C \lor l))  &
\allpaths\Always (Q \rightarrow  \somepathind\Next (D \lor \neg l))} 
\]
%
\vspace{\myspace}
%
\[
\infer %[\textit{Initial Resolution}]
{\allpaths\Always (\lstart \rightarrow (C \lor D))}
{\allpaths\Always( \ltrue \rightarrow (C \lor l))  &
\allpaths\Always(\lstart \rightarrow (D \lor \neg l))} 
%
\qquad
%
\infer %[\textit{Step Resolution}]
{\allpaths\Always(P \land Q  \rightarrow  \allpaths \Next (C \lor D))}
{\allpaths\Always(P \rightarrow \allpaths\Next (C \lor l))  &
\allpaths\Always (Q \rightarrow  \allpaths\Next (D \lor \neg l))} 
\]
%
\vspace{\myspace}
\[
%
 \infer %[\textit{Initial Resolution}]
 {\allpaths\Always (\ltrue \rightarrow (C \lor D))}
 {\allpaths\Always( \ltrue \rightarrow (C \lor l))  &
 \allpaths\Always(\ltrue \rightarrow (D \lor \neg l))} 
%
\qquad
%
\infer %[\textit{Step Resolution}]
{\allpaths\Always(P \land Q  \rightarrow  \somepathind \Next (C \lor D))}
{\allpaths\Always(P \rightarrow \allpaths\Next (C \lor l))  &
\allpaths\Always (Q \rightarrow  \somepathind\Next (D \lor \neg l))} 
%
\]
%
\vspace{\myspace}
%
\[
\infer %[\textit{Step Resolution}]
{\allpaths\Always(P \rightarrow  \allpaths \Next (C \lor D))}
{\allpaths\Always(\ltrue \rightarrow  (C \lor l))  &
\allpaths\Always (P \rightarrow  \allpaths \Next (D \lor \neg l))} 
%
\qquad
%
\infer %[\textit{Step Resolution}]
{\allpaths\Always(P \rightarrow  \somepathind \Next (C \lor D))}
{\allpaths\Always(\ltrue \rightarrow  (C \lor l))  &
\allpaths\Always (P \rightarrow  \somepathind \Next (D \lor \neg l))} 
\]
\vspace{\myspace}
\[
\infer[\textit{(ERES1)} ]
{\textstyle \allpaths\Always (Q \rightarrow  \allpaths (\neg P^\dagger  \unless l))}
{\allpaths\Always (P^\dagger \rightarrow  \somepath \Next \somepath \Always l) &
\allpaths\Always  (D   \rightarrow  \allpaths \Eventually \neg l)}
%
\quad
%
\infer[\textit{(ERES2)} ]
{\textstyle \allpaths\Always  (Q \rightarrow  \somepathind (\neg
  P^\dagger  \unless \neg l))}
{\allpaths\Always  (P^\dagger  \rightarrow  \somepathind \Next \somepathind \Always l) &
\allpaths \Always  (Q   \rightarrow  \somepathind \Eventually \neg l)}
\]
%
\vspace{\myspace}
%
\[
\allpaths\Always(P  \rightarrow  \allpaths \Next \lfalse)
\Rightarrow
\allpaths\Always(\ltrue  \rightarrow  \neg P)
%
\qquad
%
\allpaths\Always(P  \rightarrow  \somepathind \Next \lfalse)
\Rightarrow
\allpaths\Always(\ltrue  \rightarrow  \neg P)
\]
%
where $l$ is a literal, 
$C$ and $D$ are (possibly empty) disjunctions of literals,
$P$ and $Q$ are (possibly empty) conjunctions of literals,
$P^\dagger \rightarrow  \varphi$, 
$\varphi\in\{\somepath \Next \somepath \Always l,
             \somepathind \Next \somepathind \Always l\}$, 
represents a set of clauses that together imply $\varphi$. 
%$\{\Always(P^i_j\rightarrow\star^{i_j} C^i_j\}$
%with $\star^{i_j}$ either being empty or being an operator
%in $\{\Always\Next\}\cup\{\somepathind\Next|\mathit{ind}\in\mathsf{Ind}\}$.

Derivations terminate if either $\allpaths\Always(\lstart\rightarrow\lfalse)$ or
$\allpaths\Always(\ltrue\rightarrow\lfalse)$  is derived (unsatisfiable) or no new
clause can be derived (satisfiable).    
\end{small}

\end{calculus}


\begin{clarifications}
  This calculus is for propositional computation tree
  logic~\cite{Clarke+Emerson@LP1981}.
  Formulae are first translated, in a satisfiability preserving way,
  into the following normal form: 
  $\allpaths \Always (\lstart \rightarrow A)$, an \emph{initial clause},
  $\allpaths  \Always (\ltrue \rightarrow A)$, a \emph{global clause},
  $\allpaths \Always (P \rightarrow  \eitherpath \Next C)$,  
  a $P$-\emph{step clause}, and
  $\allpaths  \Always  (P   \rightarrow  \eitherpath \Eventually l)$,
  a $\eitherpath$-\emph{eventuality clause} 
  where $\eitherpath$ represents  either $\allpaths$ or $\somepathind$.
  %
  Indices $\mathit{ind}$ attached to existential path operators 
  $\somepathind$ are elements of an arbitrary enumerable set
  $\mathit{Ind}$; they are introduced during the transformation to normal
  form to represent a particular path and are used to
  preserve satisfiability.
  % 
  The logical constant $\lstart$ only holds in the first moment in time. 
  %
  %Several global or step clauses are needed to be found to satisfy the
  %first premise of the ERES rules. 
  %
  In the rules, $\ltrue$ stands for an empty conjunction of literals,  
  $\lfalse$ stands for an empty disjunction of literals.
  The resolvents of the ERES rules need transformation
  into the normal form. 
  %
\end{clarifications}

\begin{history}
  The calculus was first presented
  in~\cite{Zhang+Hustadt+Dixon@CADE2009}.
  It removes two redundant rules from an earlier resolution calculus for
  CTL~\cite{BF99:jetai}.
  Full details, including a normal form transformation and algorithms
  for the application of ERES1 and ERES2, are provided in~\cite{Zhang+Hustadt+Dixon@ToCL2014}. 
  The calculus has been implemented in the prover
  CTL-RP~\cite{Zhang+Hustadt+Dixon@AIC2010}. 
\end{history}

\begin{technicalities}
  Soundness, completeness and termination are shown in~\cite{Zhang+Hustadt+Dixon@ToCL2014}.
\end{technicalities}

\end{entry}
